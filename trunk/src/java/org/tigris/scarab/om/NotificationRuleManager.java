
package org.tigris.scarab.om;

import java.util.List;

import org.apache.torque.TorqueException;
import org.apache.torque.util.Criteria;
import org.tigris.scarab.notification.ActivityType;
import org.tigris.scarab.notification.Notification;
import org.tigris.scarab.notification.NotificationManagerFactory;
import org.tigris.scarab.tools.localization.L10NKeySet;
import org.tigris.scarab.util.ScarabException;

/**
 * This class manages NotificationRule objects.
 *
 * Notification rule table to determine when a notification has to be sent out to whom. Used by NotificationManager.
 *
 * The skeleton for this class was autogenerated by Torque  * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 */
public class NotificationRuleManager
    extends org.tigris.scarab.om.BaseNotificationRuleManager
{
    /**
     * Creates a new <code>NotificationRuleManager</code> instance.
     *
     * @exception TorqueException if an error occurs
     */
    public NotificationRuleManager()
        throws TorqueException
    {
        super();
    }
    public static NotificationRule getNotificationRule(NotificationStatus notif) throws ScarabException
    {
        NotificationRule rule = null;
        try
        {
            Long issueId = notif.getIssueId();
            Issue issue = IssueManager.getInstance(issueId);
            Integer moduleId = issue.getModuleId();
            Integer userId = notif.getReceiverId();
            ActivityType activityType = notif.getActivityType();
            rule = getNotificationRule(moduleId, userId, activityType.getCode());
        }
        catch(TorqueException te)
        {
            throw new ScarabException(L10NKeySet.ExceptionTorqueGeneric, te);
        }
        return rule;
    }
    
    public static NotificationRule getNotificationRule(Integer moduleId, Integer userId, String activityType) throws ScarabException
    {
        NotificationRule rule = null;
        
        int managerId = NotificationManagerFactory.getInstance().getManagerId();
        Criteria crit = new Criteria();
        crit.add(NotificationRulePeer.USER_ID, userId);
        crit.add(NotificationRulePeer.MODULE_ID, moduleId);
        crit.add(NotificationRulePeer.ACTIVITY_TYPE, activityType);
        crit.add(NotificationRulePeer.MANAGER_ID, managerId);
                
        try
        {
            List<NotificationRule> ruleSet = (List<NotificationRule>)NotificationRulePeer.doSelect(crit);     
            if(ruleSet == null || ruleSet.size()==0)
            {

                rule = NotificationRule.createDefaultRule( 
                       moduleId, 
                       userId,
                       managerId,
                       activityType);
            }
            else if (ruleSet.size() > 1)
            {
                String msg = "Database inxonsistency:"
                           + " Expected at most one key matching (user_id,module_id,activity_type,manager_id) = "
                           + ")" + userId + "," + moduleId + "," + activityType + "," + managerId + ")";
                throw new TorqueException(msg,new Throwable());
            }
            else
            {
                rule = ruleSet.get(0);
            }
        }
        catch(TorqueException te)
        {
            throw new ScarabException(L10NKeySet.ExceptionTorqueGeneric,te);
        }

        return rule;
    }

    /**
     * determines whether user has enabled notifications for given activityType
     * in given module.
     * @param user
     * @param act
     * @return
     * @throws ScarabException 
     * @throws TorqueException 
     */
    public static boolean isNotificationEnabledFor(ScarabUser user, Issue issue, boolean isSelf, String activityType, boolean hasGetSealedActivity) throws ScarabException, TorqueException
    {
        Integer userId   = user.getUserId();
        Module module    = issue.getModule();
        Integer moduleId = module.getModuleId();
        
        NotificationRule rule = getNotificationRule(moduleId, userId, activityType);
        boolean isEnabled;
        if(isSelf)
        {
            isEnabled = rule.getSendSelf();
        }
        else
        {
            if(issue.isSealed() && !hasGetSealedActivity)
            {
                isEnabled = false; // Do not send notifications to other users when Issue is "closed"
            }
            else
            {
                isEnabled = rule.getFilterState();
            }
        }
        
        if(isEnabled)
        {
            Notification notification = new Notification(user, issue);
            isEnabled = notification.sendConditionsMatch();
        }
        return isEnabled;
    }

    
}
